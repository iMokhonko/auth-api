const { DynamoDBClient, GetItemCommand, PutItemCommand, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
const dynamoDbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const { marshall, unmarshall } = require("@aws-sdk/util-dynamodb");

const { createJsonResponse } = require('lambda-nodejs-response-helper');
const transformUnitToTTL = require('./helpers/transform-unit-to-ttl');
const generateRateLimitHeaders = require('./helpers/generate-rate-limit-headers');

// holds userIds that was rate limited
const RATE_LIMITED_CACHE = new Map();
let LAST_CACHE_CLEAN_UP_TIME = Date.now() / 1000;

const clearExpiredCachedItems = () => {
  const currentTime = Date.now() / 1000;
  
  for (let [userId, ttl] of RATE_LIMITED_CACHE.entries()) {
      if (ttl < currentTime) {
        RATE_LIMITED_CACHE.delete(userId);
      }
  }
}

const getRateLimitItem = async (tableName, pk, sk) => {
  try {
    const rateLimitItem = await dynamoDbClient.send(new GetItemCommand({
      TableName: tableName,
      Key: marshall({ pk, sk })
    }));

    if(!rateLimitItem?.Item) {
      return null;
    }

    const { value, ttl } = unmarshall(rateLimitItem.Item);

    // if item expired
    if((Date.now() / 1000) > ttl) {
      return null;
    }
  
    return { value, ttl };
  } catch(e) {
    return null;
  }
}

const upsertRateLimitItem = async (tableName, pk, sk, value = null, ttl = null) => {
  try {
    if (value && ttl) {
      return await dynamoDbClient.send(new PutItemCommand({
        TableName: tableName,
        Item: marshall({ pk, sk, value, ttl })
      }));
    } else {
      const params = {
        TableName: tableName,
        Key: marshall({ pk, sk }),
        UpdateExpression: "SET #value = #value - :val",
        ConditionExpression: "attribute_exists(#value) AND #value > :minVal",
        ExpressionAttributeNames: { "#value": "value" },
        ExpressionAttributeValues: marshall({ ":val": 1, ':minVal': 0 }),
        ReturnValues: "UPDATED_NEW"
      };

      try {
        return await dynamoDbClient.send(new UpdateItemCommand(params));
      } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
          // Do nothing or handle as needed, operation was skipped because value is already 0
          return null;
        } else {
          throw error;
        }
      }
    }
  } catch(e) {
    console.error(e);
    return null;
  }
}

exports.tokenRateLimiter = (options = {}) => (handler) => async (event, context) => {
  const {
    rateLimit = 5,
    rateLimitUnit = 'minute',
    rateLimitDynamoDBTableName,
    rateLimitActionName = process.env.AWS_LAMBDA_FUNCTION_NAME
  } = options;

  const ruleTTL = transformUnitToTTL(rateLimitUnit);

  // check if we need to perform clean up for expired items in cache
  if((Date.now() / 1000) > (LAST_CACHE_CLEAN_UP_TIME + ruleTTL)) {
    clearExpiredCachedItems();
    LAST_CACHE_CLEAN_UP_TIME = Date.now() / 1000;
  }

  const rateLimitPK = `USER#ID#${options.userId}#`;
  const rateLimitSk = `RATE_LIMIT#${rateLimitActionName}#`;

  const localCacheUserRateLimitTTl = RATE_LIMITED_CACHE.get(options.userId);

  // if local in memory cache has record that this user ID was rate limited then return 429 immediately
  if(localCacheUserRateLimitTTl && localCacheUserRateLimitTTl >= (Date.now() / 1000)) {
    return createJsonResponse(
      429,
      { message: 'Too many requests' },
      generateRateLimitHeaders(
        rateLimit, 
        0,
        localCacheUserRateLimitTTl
      )
    );
  }

  // if there is a rate limit record inside in-memory cache and it is expired then delete it
  if(localCacheUserRateLimitTTl && localCacheUserRateLimitTTl <= (Date.now() / 1000)) {
    RATE_LIMITED_CACHE.delete(options.userId);
  }

  const rateLimitValue = await getRateLimitItem(rateLimitDynamoDBTableName, rateLimitPK, rateLimitSk);

  if(rateLimitValue === null) {
    const expirationTimestamp = Math.ceil((Date.now() / 1000)) + ruleTTL;

    await upsertRateLimitItem(
      rateLimitDynamoDBTableName, 
      rateLimitPK, 
      rateLimitSk, 
      rateLimit - 1, 
      expirationTimestamp
    );

    const handlerResponse = await handler(event, context);

    return {
      ...handlerResponse,
      headers: {
        ...(handlerResponse?.headers ?? {}),
        ...generateRateLimitHeaders(
          rateLimit, 
          rateLimit - 1, 
          expirationTimestamp
        )
      }
    }
  } else {
    // rate limit exceeded
    if(rateLimitValue.value < 1) {
      // save rate limited userId to local cache with ttl value;
      RATE_LIMITED_CACHE.set(options.userId, rateLimitValue.ttl);

      return createJsonResponse(
        429,
        { message: 'Too many requests' },
        generateRateLimitHeaders(
          rateLimit, 
          0,
          rateLimitValue.ttl
        )
      );
    } else {
      // decrement rate limit value by one and allow request
      // in order to reduce latency we do not wait for response
      upsertRateLimitItem(
        rateLimitDynamoDBTableName, 
        rateLimitPK, 
        rateLimitSk
      );

      const handlerResponse = await handler(event, context);

      return {
        ...handlerResponse,
        headers: {
          ...(handlerResponse?.headers ?? {}),
          ...generateRateLimitHeaders(
            rateLimit, 
            rateLimitValue.value - 1, 
            rateLimitValue.ttl
          )
        }
      }

    }
  }
};