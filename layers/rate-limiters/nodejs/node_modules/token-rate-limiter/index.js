const { DynamoDBClient, GetItemCommand, PutItemCommand, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
const dynamoDbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const { marshall, unmarshall } = require("@aws-sdk/util-dynamodb");

const createReponse = require('./helpers/create-response');
const transformUnitToTTL = require('./helpers/transform-unit-to-ttl');
const generateRateLimitHeaders = require('./helpers/generate-rate-limit-headers');
const executeNext = require('./helpers/execute-next');

// holds userIds that was rate limited
const RATE_LIMITED_CACHE = new Map();
let LAST_CACHE_CLEAN_UP_TIME = Date.now() / 1000;

const clearExpiredCachedItems = () => {
  const currentTime = Date.now() / 1000;
  
  for (let [userId, ttl] of RATE_LIMITED_CACHE.entries()) {
      if (ttl < currentTime) {
        RATE_LIMITED_CACHE.delete(userId);
      }
  }
}

const getRateLimitItem = async (tableName, pk, sk) => {
  try {
    const rateLimitItem = await dynamoDbClient.send(new GetItemCommand({
      TableName: tableName,
      Key: marshall({ pk, sk })
    }));

    if(!rateLimitItem?.Item) {
      return null;
    }

    const { value, ttl } = unmarshall(rateLimitItem.Item);

    // if item expired
    if((Date.now() / 1000) > ttl) {
      return null;
    }
  
    return { value, ttl };
  } catch(e) {
    return null;
  }
}

const upsertRateLimitItem = async (tableName, pk, sk, value = null, ttl = null) => {
  try {
    if (value && ttl) {
      return await dynamoDbClient.send(new PutItemCommand({
        TableName: tableName,
        Item: marshall({ pk, sk, value, ttl })
      }));
    } else {
      const params = {
        TableName: tableName,
        Key: marshall({ pk, sk }),
        UpdateExpression: "SET #value = #value - :val",
        ConditionExpression: "attribute_exists(#value) AND #value > :minVal",
        ExpressionAttributeNames: { "#value": "value" },
        ExpressionAttributeValues: marshall({ ":val": 1, ':minVal': 0 }),
        ReturnValues: "UPDATED_NEW"
      };

      try {
        return await dynamoDbClient.send(new UpdateItemCommand(params));
      } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
          // Do nothing or handle as needed, operation was skipped because value is already 0
          return null;
        } else {
          throw error;
        }
      }
    }
  } catch(e) {
    console.error(e);
    return null;
  }
}

exports.tokenRateLimiter = async (event, context, options = {}, next) => {
  const {
    rateLimit = 5,
    rateLimitUnit = 'minute'
  } = options;

  const ruleTTL = transformUnitToTTL(rateLimitUnit);

  // check if we need to perform clean up for expired items in cache
  if((Date.now() / 1000) > (LAST_CACHE_CLEAN_UP_TIME + ruleTTL)) {
    clearExpiredCachedItems();
    LAST_CACHE_CLEAN_UP_TIME = Date.now() / 1000;
  }

  const rateLimitPK = `USER#ID#${options.userId}#`;
  const rateLimitSk = `RATE_LIMIT#${process.env.AWS_LAMBDA_FUNCTION_NAME}#`;

  const localCacheUserRateLimitTTl = RATE_LIMITED_CACHE.get(options.userId);

  // if local in memory cache has record that this user ID was rate limited then return 429 immediately
  if(localCacheUserRateLimitTTl && localCacheUserRateLimitTTl >= (Date.now() / 1000)) {
    return createReponse(
      429,
      generateRateLimitHeaders(
        rateLimit, 
        0,
        localCacheUserRateLimitTTl
      )
    );
  }

  // if there is a rate limit record inside in-memory cache and it is expired then delete it
  if(localCacheUserRateLimitTTl && localCacheUserRateLimitTTl <= (Date.now() / 1000)) {
    RATE_LIMITED_CACHE.delete(options.userId);
  }

  const rateLimitValue = await getRateLimitItem(options.tableName, rateLimitPK, rateLimitSk);

  if(rateLimitValue === null) {
    const expirationTimestamp = Math.ceil((Date.now() / 1000)) + ruleTTL;

    await upsertRateLimitItem(
      options.tableName, 
      rateLimitPK, 
      rateLimitSk, 
      rateLimit - 1, 
      expirationTimestamp
    );

    return await executeNext(
      event, 
      context, 
      next, 
      generateRateLimitHeaders(
        rateLimit, 
        rateLimit - 1, 
        expirationTimestamp
      )
    );
  } else {
    // rate limit exceeded
    if(rateLimitValue.value < 1) {
      // save rate limited userId to local cache with ttl value;
      RATE_LIMITED_CACHE.set(options.userId, rateLimitValue.ttl);

      return createReponse(
        429,
        generateRateLimitHeaders(
          rateLimit, 
          0,
          rateLimitValue.ttl
        )
      );
    } else {
      // decrement rate limit value by one and allow request
      // in order to reduce latency we do not wait for response
      upsertRateLimitItem(
        options.tableName, 
        rateLimitPK, 
        rateLimitSk
      );

      // call next handler
      return await executeNext(
        event, 
        context, 
        next, 
        generateRateLimitHeaders(
          rateLimit, 
          rateLimitValue.value - 1, 
          rateLimitValue.ttl
        )
      );
    }
  }
}