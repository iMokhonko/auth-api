const { DynamoDBClient, GetItemCommand, PutItemCommand, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
const dynamoDbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const { marshall, unmarshall } = require("@aws-sdk/util-dynamodb");

const createReponse = require('./helpers/create-response');
const transformUnitToTTL = require('./helpers/transform-unit-to-ttl');
const generateRateLimitHeaders = require('./helpers/generate-rate-limit-headers');
const executeNext = require('./helpers/execute-next');

const getRateLimitItem = async (tableName, pk, sk) => {
  try {
    const rateLimitItem = await dynamoDbClient.send(new GetItemCommand({
      TableName: tableName,
      Key: marshall({ pk, sk })
    }));

    if(!rateLimitItem?.Item) {
      return null;
    }

    const { value, ttl } = unmarshall(rateLimitItem.Item);

    // if item expired
    if((Date.now() / 1000) > ttl) {
      return null;
    }
  
    return { value, ttl };
  } catch(e) {
    return null;
  }
}

const upsertRateLimitItem = async (tableName, pk, sk, value = null, ttl = null) => {
  try {
    if (value && ttl) {
      return await dynamoDbClient.send(new PutItemCommand({
        TableName: tableName,
        Item: marshall({ pk, sk, value, ttl })
      }));
    } else {
      const params = {
        TableName: tableName,
        Key: marshall({ pk, sk }),
        UpdateExpression: "SET #value = #value - :val",
        ConditionExpression: "attribute_exists(#value) AND #value > :minVal",
        ExpressionAttributeNames: { "#value": "value" },
        ExpressionAttributeValues: marshall({ ":val": 1, ':minVal': 0 }),
        ReturnValues: "UPDATED_NEW"
      };

      try {
        return await dynamoDbClient.send(new UpdateItemCommand(params));
      } catch (error) {
        if (error.name === 'ConditionalCheckFailedException') {
          // Do nothing or handle as needed, operation was skipped because value is already 0
          return null;
        } else {
          throw error;
        }
      }
    }
  } catch(e) {
    console.error(e);
    return null;
  }
}

exports.tokenRateLimiter = async (event, context, options = {}, next) => {
  const {
    rateLimit = 5,
    rateLimitUnit = 'minute'
  } = options;

  const rateLimitPK = `USER#ID#${options.userId}#`;
  const rateLimitSk = `RATE_LIMIT#${process.env.AWS_LAMBDA_FUNCTION_NAME}#`;

  const rateLimitValue = await getRateLimitItem(options.tableName, rateLimitPK, rateLimitSk);

  console.log('rateLimitValue', rateLimitValue);

  if(rateLimitValue === null) {
    const ruleTTL = transformUnitToTTL(rateLimitUnit);
    const expirationTimestamp = Math.ceil((Date.now() / 1000)) + ruleTTL;

    await upsertRateLimitItem(
      options.tableName, 
      rateLimitPK, 
      rateLimitSk, 
      rateLimit - 1, 
      expirationTimestamp
    );

    return await executeNext(
      event, 
      context, 
      next, 
      generateRateLimitHeaders(
        rateLimit, 
        rateLimit - 1, 
        expirationTimestamp
      )
    );
  } else {
    // rate limit exceeded
    if(rateLimitValue.value < 1) {
      return createReponse(
        429,
        generateRateLimitHeaders(
          rateLimit, 
          0,
          rateLimitValue.ttl
        )
      );
    } else {
      // decrement rate limit value by one and allow request
      await upsertRateLimitItem(
        options.tableName, 
        rateLimitPK, 
        rateLimitSk
      );

      // call next handler
     return await executeNext(
        event, 
        context, 
        next, 
        generateRateLimitHeaders(
          rateLimit, 
          rateLimitValue.value - 1, 
          rateLimitValue.ttl
        )
      );
    }
  }
}